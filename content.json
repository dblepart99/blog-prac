{"pages":[{"title":"","text":"About MeHello, I’m Hyunsoo KimActivation React와 React-Native를 활용한 앱과 모바일웹 개발 수료(한국공개소프트웨어협회) 2018.04 ProEdu(충남대학교 코딩 교육 봉사단), 2020.03 ~ 팀 “코딩이나 해”(학업 상상 튜터링), 2020.04 ~ Projects Korea Alert CExtension - 전국 재난 알림문자확인 크롬 확장프로그램 (2020) Emotionary KingBamboo Patent 방충망이 구비된 태양광 블라인드(Solar Photovotaic blind) (2016) Education Daejeon Jungang High, 2015.03 ~ 2018.02 ChungNam Nat’l Univ. Computer Science Engineering 18.03 ~ Military ROK Army, 2019.01.14 ~ 2020.01.17 Social Agent, 2020.06.01 ~ 2021.01.22 Contact Me! Github","link":"/about/index.html"},{"title":"All-Categories","text":"","link":"/all-categories/index.html"},{"title":"All-Tags","text":"","link":"/all-tags/index.html"}],"posts":[{"title":"정렬","text":"Selection SortAs you can see the word “Selection”. This algorithm always chooses the most minimum element in the array repeatedly from unsorted part and swap with the first element of unsorted part. 이름에서 볼 수 있듯 “선택”하는 정렬입니다. 이 알고리즘은 항상 배열이 정렬되지 않은 부분에서 최소의 원소를 정렬되지 않은 부분의 맨 앞으로 가져와 정렬합니다. 12345678arr = [10, 20, 3, 7, 5]설명을 위해 &quot;|&quot;를 기준으로 구분하겠습니다. unsorted part|sorted part=&gt; | 10 20 3 7 5=&gt; 3 | 10 20 7 5=&gt; 3 5 | 10 20 7=&gt; 3 5 7 | 10 20=&gt; 3 5 7 10 | 20=&gt; 3 5 7 10 20 123456789def selectsort(array): for i in range(len(array)): min_idx = i #index of the minimum value for j in range(i + 1, len(array)): if array[min_idx] &gt; array[j]: min_idx = j array[i], array[min_idx] = array[min_idx], array[i] return array 1arr = [10, 20, 3, 7, 5] 1selectsort(arr) [3, 5, 7, 10, 20] 선택 정렬은 N-1번 만큼 가장 작은수를 찾아서 맨 앞으로 보내야합니다. (N번이 아닌 이유는 선택받지 못한 가장 마지막 원소는 가장 큰 원소이기 때문입니다.) 시간복잡도로 따지면 반복문이 이중 중첩이므로 O(N^2)입니다. Insertion Sort삽입 정렬도 이름에서 볼 수 있듯이 매우 직관적입니다. 삽입 정렬은 원소를 특정한 위치에 적절히 삽입합니다.“적절히”라는 말이 참 애매할 수 있지만, 이 보다 더 정확한 표현도 없을 것 같습니다. 12345678def insertionsort(array): for i in range(1, len(array)): for j in range(i, 0, -1): if array[j] &lt; array[j-1]: array[j], arr[j-1] = array[j-1], array[j] else: break return array 1arr = [10, 20, 3, 7, 5] 1insertionsort(arr) [3, 5, 7, 10, 20] 1","link":"/2021/09/01/Sort/"},{"title":"","text":"Selection SortAs you can see the word “Selection”. This algorithm always chooses the most minimum element in the array repeatedly from unsorted part and swap with the first element of unsorted part. 이름에서 볼 수 있듯 “선택”하는 정렬입니다. 이 알고리즘은 항상 배열이 정렬되지 않은 부분에서 최소의 원소를 정렬되지 않은 부분의 맨 앞으로 가져와 정렬합니다. 12345678arr = [10, 20, 3, 7, 5]설명을 위해 &quot;|&quot;를 기준으로 구분하겠습니다. unsorted part|sorted part=&gt; | 10 20 3 7 5=&gt; 3 | 10 20 7 5=&gt; 3 5 | 10 20 7=&gt; 3 5 7 | 10 20=&gt; 3 5 7 10 | 20=&gt; 3 5 7 10 20 123456789def selectsort(array): for i in range(len(array)): min_idx = i #index of the minimum value for j in range(i + 1, len(array)): if array[min_idx] &gt; array[j]: min_idx = j array[i], array[min_idx] = array[min_idx], array[i] return array 1arr = [10, 20, 3, 7, 5] 1selectsort(arr) [3, 5, 7, 10, 20] 선택 정렬은 N-1번 만큼 가장 작은수를 찾아서 맨 앞으로 보내야합니다. (N번이 아닌 이유는 선택받지 못한 가장 마지막 원소는 가장 큰 원소이기 때문입니다.) 시간복잡도로 따지면 반복문이 이중 중첩이므로 O(N^2)입니다. 1","link":"/2021/09/01/Untitled/"},{"title":"Xcode빌드시 Unable to Login With Account 오류 해결","text":"xcode에서 갑자기 빌드가 되지 않아 매우 당황스러웠다..아래 과정을 따라하면 해결할 수 있다. Xcode -&gt; Preferences Accounts -&gt; 계정 재로그인 참고자료","link":"/2021/07/21/xcode-%EC%98%A4%EB%A5%98/"},{"title":"모각코 1회차","text":"모각코 1회차 계획 백준 10808 알파벳 갯수 문제 풀기 모각코 1회차 결과백준 배열 문제 연습백준 10808 알파벳 갯수 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int arr[26] = {0,}; char str[101]; cin &gt;&gt; str; int i = 0; while(str[i]!='\\0'){ arr[str[i]-'a']++; i++; } for(int i = 0; i &lt;sizeof(arr)/sizeof(int); i++){ cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;; } return 0;} 입력받은 문자열의 알파벳 개수를 세는 문제입니다. 알파벳의 전체 갯수인 길이 26인 배열을 생성한 후, 문자열에 있는 알파벳의 순서와 같은 인덱스의 배열을 늘려가면서 알파벳의 갯수를 셉니다.","link":"/2021/07/15/%EB%AA%A8%EA%B0%81%EC%BD%94-1%ED%9A%8C%EC%B0%A8/"},{"title":"모각코-2회차","text":"모각코 2회차 계획 바킹독 0x03강 강의 듣기 모각코 2회차 결과바킹독 0x03강 배열 강의를 들으며 정리한 내용입니다. 배열정의배열은 메모리 상에 원소를 연속하게 저장하는 자료구조입니다. 성질 배열은 O(1)의 시간복잡도로 원소에 접근가능합니다. 추가적으로 소모되는 메모리의 양이 거의 없습니다. Cache hit rate 메모리 상에 연속하게 잡아 할당에 제약이 걸림. C++ 배열 초기화123456789101112131415161718192021int a[20];int b[20][20];//1. memsetmemset(a, 0, sizeof a);memset(b, 0, sizeof b);//2. forfor(int i = 0; i &lt; 20;i++){ a[i] = 0;}for(int i = 0; i &lt; 20; i++){ for(int j = 0; j &lt; 20; j++){ b[i][j] = 0; }}//3. fillfill(a, a + 20, 0);for(int i = 0; i &lt; 20; i++){ fill(b[i], b[i]+20; 0);} memset함수는 cstring헤더에 있음. 0이나 -1 이외의 값은 오동작. 2차원 이상의 배열을 함수의 인자로 넘길 경우, 잘못 들어가기도 함. 실수할 여지로 비추천. for문 사용은 투박하지만 실수할 여지가 없음. algorithm헤더의 fill함수를 이용하는 것. 실수할 여지도 없고, 코드가 짧아 추천. STL vectorSTL vector는 배열과 매우 흡사합니다. 그러나 배열과 달리 크기를 자유자재로 늘이거나 줄일 수 있다는 장점이 있습니다.","link":"/2021/07/16/%EB%AA%A8%EA%B0%81%EC%BD%94-2%ED%9A%8C%EC%B0%A8/"},{"title":"모각코-3회차","text":"모각코 3회차 계획 백준 1475 방 번호 풀기 모각코 3회차 결과백준 1475 방 번호 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int arr[10]; fill(arr, arr+10, 0); int N; cin &gt;&gt; N; if(N==0){ cout &lt;&lt; 1; return 0; } while(N&gt;0){ int tmp = N%10; N/=10; arr[tmp]++; } arr[6] += arr[9]; if(arr[6]%2!=0){ arr[6]=arr[6]/2+1; }else{ arr[6]/=2; } arr[9] = 0; int max = *max_element(arr, arr+10); cout &lt;&lt; max; return 0;} 문제에 의하면 6과 9는 뒤집어서 이용할 수 있습니다. 그래서 모든 6과 9의 갯수를 더한 후, 2로 나누어 세트의 개수를 구할 수 있습니다. ex) 6669 =&gt; 6을 2장, 9를 2장으로 만들 수 있음.6과 9의 갯수를 더한 후, 2로 나누어줍니다. 만약 나머지가 있다면 한 세트를 더 뜯어야 한다는 뜻이므로 1을 더해줍니다. 주의 사항 0번 부터 9번까지의 숫자들이므로, 0 한 장만 입력받는 경우도 고려를 해야합니다.","link":"/2021/07/22/%EB%AA%A8%EA%B0%81%EC%BD%94-3%ED%9A%8C%EC%B0%A8/"},{"title":"모각코-4회차","text":"모각코 4회차 계획 RDBMS란? Database Schema란? 모각코 4회차 결과1. RDBMS란? RDBMS는 Relational Database Management System의 약자로 관계형 데이터베이스 시스템을 지칭한다. 역사가 오래되었고, 신뢰성이 높으며 데이터 분류, 정렬, 탐색 속도가 빠릅니다. 관계형 데이터베이스는 테이블 형식을 이용하여 데이터를 정의하고 설명하는 데이터 모델입니다. 용어 정리 Primary Key : 한 테이블의 각 row를 유일하게 식별해주는 column Forein Key : 한 테이블의 필드 중 다른 테이블의 row를 식별 할 수 있는 키 2. Database Schema란?데이터베이스에서 자료의 구조, 자료의 표현 방법, 자료 간의 관계를 형식 언어로 정의한 구조입니다. 데이터베이스 사용자가 자료를 저장, 조회, 삭제, 변경할 때 DBMS는 자신이 생성한 데이터베이스 스키마를 참조하여 명령을 수행합니다. 스키마 3층 구조 외부 스키마 개념 스키마 내부 스키마","link":"/2021/07/23/%EB%AA%A8%EA%B0%81%EC%BD%94-4%ED%9A%8C%EC%B0%A8/"},{"title":"모각코-5회차","text":"모각코 5회차 계획 Pull Request란 무엇인지? Github Octokit 라이브러리 조사해보기 모각코 5회차 결과Pull Request란?Github는 오픈소스 커뮤니티로 다른 개발자들과 코드를 공유하고, 협업할 수 있는 곳입니다. 이 중에서 Pull Reqeust라는 기능이 있습니다. Pull Request를 한국어로 직역해보겠습니다. ‘당기다 요청’이 됩니다.다른 개발자의 코드를 fork햐여 개발한 후, 코드를 수정한 후 본인이 수정한 코드가 그 개발자의 repo에 반영되기를 바랄 경우 보통 ‘PR을 날린다’라는 표현을 사용하게 됩니다. Octokit Library란?Octokit Library는 github api를 쉽게 사용할 수 있도록 도와주는 라이브러리입니다.","link":"/2021/07/29/%EB%AA%A8%EA%B0%81%EC%BD%94-5%ED%9A%8C%EC%B0%A8/"},{"title":"모각코-6회차","text":"모각코 6회차 계획지난 5회차에 이어 Octokit 라이브러리 예제 코드들을 작성해볼 예정입니다. 모각코 6회차 결과Octokit Library로 Pull Request생성하기 Createing Commit using Octokit library 123456789101112131415161718192021222324252627282930313233const atob = require(&quot;atob&quot;);const btoa = require(&quot;btoa&quot;);const { Octokit } = require(&quot;@octokit/core&quot;);const octokit = new Octokit({ auth: &quot;yout token&quot;,});async function makeCommittoRepo() { const response = await octokit.request( &quot;GET /repos/{owner}/{repo}/contents/{path}&quot;, { owner: &quot;ownername&quot;, repo: &quot;repo name&quot;, path: &quot;file path&quot;, } ); const beforeSHA = response.data.sha; const before = atob(response.data.content); const inputLine = &quot;content that you want to make&quot;; const content = btoa(before.concat(inputLine)); await octokit.request(&quot;PUT /repos/{owner}/{repo}/contents/{path}&quot;, { owner: &quot;ownername&quot;, repo: &quot;repo name&quot;, path: &quot;file path&quot;, content: content, message: &quot;changed your repo&quot;, sha: beforeSHA, });}makeCommittoRepo(); Github의 작업의 특징은 버전관리입니다. 이를 위해 commit 하기 전 이전 commit의 sha를 읽어와야 합니다. Creating Pull Request 12345678910111213141516171819const { Octokit } = require(&quot;@octokit/core&quot;);const octokit = new Octokit({ auth: &quot;your token&quot;,});async function makePRfromAtoB() { // B의 레포를 fork한 후 A가 수정하여 PR을 날리는 경우 await octokit.request(&quot;POST /repos/{owner}/{repo}/pulls&quot;, { owner: &quot;userB&quot;, // 풀리퀘 받을 학생 이름 -&gt; B title: &quot;PR title&quot;, // 풀리퀘 제목 repo: &quot;targetRepo&quot;, // 풀리퀘 날릴 레포 이름 body: &quot;pull request body&quot;, // 풀리퀘 관련 내용 head: &quot;A:main&quot;, //A의 이름:branch 이름 base: &quot;main&quot;, //B의 branch 이름 });}makePRfromAtoB(); Reading file from github using Octokit Library 123456789101112131415161718192021222324252627const axios = require(&quot;axios&quot;);const atob = require(&quot;atob&quot;);const btoa = require(&quot;btoa&quot;);const { Octokit } = require(&quot;@octokit/core&quot;);const octokit = new Octokit({ auth: &quot;your token&quot;,});async function readREADME() { const response = await octokit.request( &quot;GET /repos/{owner}/{repo}/contents/{path}&quot;, { owner: &quot;username&quot;, repo: &quot;reponame&quot;, path: &quot;path of your file&quot;, } ); const readmeContent = atob(response.data.content); return readmeContent;}readREADME().then(function (value) { console.log(value);}); 읽어오는 파일들은 base64형식으로 인코딩이 된 형식으로 가져오므로, base64형식으로 decode하면 볼 수 있습니다.","link":"/2021/07/30/%EB%AA%A8%EA%B0%81%EC%BD%94-6%ED%9A%8C%EC%B0%A8/"},{"title":"모각코 - 리뷰","text":"“그럴바엔 문제나 풀어”모각코 1회차 리뷰 모각코 2회차 리뷰 모각코 3회차 리뷰 모각코 4회차 리뷰 모각코 5회차 리뷰 모각코 6회차 리뷰","link":"/2021/08/17/%EB%AA%A8%EA%B0%81%EC%BD%94-%EB%A6%AC%EB%B7%B0/"},{"title":"모각코 - 소감","text":"“그럴바엔 문제나 풀어” 소감이번 모각코의 목표는 어쨌든 “방학에도” 꾸준히 공부를 한다는 것이었습니다. 매주 꾸준히 공부하는 습관이 자리 잡는데 도움이 되어, 더 성장할 수 있는 밑거름이 된 것 같습니다. 이번 모각코에서는 하나의 주제를 갖고 공부하기 보다는, 그날 그날 공부하고 싶은 것을 정해서 하였으나 다음에는 기회가 된다면 친구들과 함께 하나의 프로젝트를 주제를 잡고 해보고 싶습니다.","link":"/2021/08/17/%EB%AA%A8%EA%B0%81%EC%BD%94-%EC%86%8C%EA%B0%90/"},{"title":"백준 10807","text":"백준 10807 개수 세기 1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int arr[201]; fill(arr, arr+201, 0); int N, tmp; cin &gt;&gt; N; for(int i = 0; i &lt; N; i++){ cin &gt;&gt; tmp; arr[tmp+100]++; } cin &gt;&gt; tmp; cout &lt;&lt; arr[tmp+100]; return 0;} 입력받을 수 있는 숫자의 범위는 -100에서 100까지 총 201개입니다. 길이가 201인 int형 배열을 선언합니다.fill함수를 이용하여 배열 전체를 0으로 초기화해줍니다. 0은 -100에서 100까지의 수 중에서 101번째의 숫자이므로, 입력받은 수 + 100 의 index의 값을 +1을 해주며 입력받은 숫자의 갯수를 세줍니다.마지막으로 입력받은 숫자의 횟수를 출력합니다.","link":"/2021/07/18/%EB%B0%B1%EC%A4%80-10807/"},{"title":"백준-1475","text":"백준 1475 방 번호 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int arr[10]; fill(arr, arr+10, 0); int N; cin &gt;&gt; N; if(N==0){ cout &lt;&lt; 1; return 0; } while(N&gt;0){ int tmp = N%10; N/=10; arr[tmp]++; } arr[6] += arr[9]; if(arr[6]%2!=0){ arr[6]=arr[6]/2+1; }else{ arr[6]/=2; } arr[9] = 0; int max = *max_element(arr, arr+10); cout &lt;&lt; max; return 0;} 문제에 의하면 6과 9는 뒤집어서 이용할 수 있습니다. 그래서 모든 6과 9의 갯수를 더한 후, 2로 나누어 세트의 개수를 구할 수 있습니다. ex) 6669 =&gt; 6을 2장, 9를 2장으로 만들 수 있음.6과 9의 갯수를 더한 후, 2로 나누어줍니다. 만약 나머지가 있다면 한 세트를 더 뜯어야 한다는 뜻이므로 1을 더해줍니다. 주의 사항 0번 부터 9번까지의 숫자들이므로, 0 한 장만 입력받는 경우도 고려를 해야합니다.","link":"/2021/07/21/%EB%B0%B1%EC%A4%80-1475/"},{"title":"Ubuntu 20.04 Fcitx 한글 입력 설정","text":"1. fcitx 설치terminal을 실행 후, 아래의 명령어를 순차적으로 입력해줍니다. 123$ sudo apt-get update$ sudo apt-get install fcitx-hangul$ sudo reboot 2. Language Support 실행하단 Keyboard input method system -&gt; fcitx 변경합니다. 1$ sudo reboot 3. fcitx 설정 상단에 생긴 키보드 버튼을 클릭 -&gt; configure 좌측 하단의 +버튼을 클릭 Only show Current Language 체크 해제 후, hangul 선택 후 OK 한/영 키 변경 상단의 global config 탭 클릭 -&gt; Trigger Input method -&gt; shif+space버튼 누르기 개인 취향에 맞춰 설정하시면 됩니다.","link":"/2021/07/29/%EC%9A%B0%EB%B6%84%ED%88%AC-fcitx-%EC%84%A4%EC%A0%95/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","link":"/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"정렬","slug":"정렬","link":"/tags/%EC%A0%95%EB%A0%AC/"},{"name":"선택정렬","slug":"선택정렬","link":"/tags/%EC%84%A0%ED%83%9D%EC%A0%95%EB%A0%AC/"},{"name":"xcode","slug":"xcode","link":"/tags/xcode/"},{"name":"xcode 오류","slug":"xcode-오류","link":"/tags/xcode-%EC%98%A4%EB%A5%98/"},{"name":"모각코","slug":"모각코","link":"/tags/%EB%AA%A8%EA%B0%81%EC%BD%94/"},{"name":"모여서 각자 코딩","slug":"모여서-각자-코딩","link":"/tags/%EB%AA%A8%EC%97%AC%EC%84%9C-%EA%B0%81%EC%9E%90-%EC%BD%94%EB%94%A9/"},{"name":"백준","slug":"백준","link":"/tags/%EB%B0%B1%EC%A4%80/"},{"name":"백준 10808","slug":"백준-10808","link":"/tags/%EB%B0%B1%EC%A4%80-10808/"},{"name":"백준 알파벳 갯수","slug":"백준-알파벳-갯수","link":"/tags/%EB%B0%B1%EC%A4%80-%EC%95%8C%ED%8C%8C%EB%B2%B3-%EA%B0%AF%EC%88%98/"},{"name":"boj 10808 cpp","slug":"boj-10808-cpp","link":"/tags/boj-10808-cpp/"},{"name":"배열","slug":"배열","link":"/tags/%EB%B0%B0%EC%97%B4/"},{"name":"STL","slug":"STL","link":"/tags/STL/"},{"name":"STL vector","slug":"STL-vector","link":"/tags/STL-vector/"},{"name":"백준 1475","slug":"백준-1475","link":"/tags/%EB%B0%B1%EC%A4%80-1475/"},{"name":"Github","slug":"Github","link":"/tags/Github/"},{"name":"PR","slug":"PR","link":"/tags/PR/"},{"name":"Pull request","slug":"Pull-request","link":"/tags/Pull-request/"},{"name":"github api","slug":"github-api","link":"/tags/github-api/"},{"name":"Octokit","slug":"Octokit","link":"/tags/Octokit/"},{"name":"Octokit Library","slug":"Octokit-Library","link":"/tags/Octokit-Library/"},{"name":"모각코 회고","slug":"모각코-회고","link":"/tags/%EB%AA%A8%EA%B0%81%EC%BD%94-%ED%9A%8C%EA%B3%A0/"},{"name":"모각코 소감","slug":"모각코-소감","link":"/tags/%EB%AA%A8%EA%B0%81%EC%BD%94-%EC%86%8C%EA%B0%90/"},{"name":"백준 10807","slug":"백준-10807","link":"/tags/%EB%B0%B1%EC%A4%80-10807/"},{"name":"ubuntu","slug":"ubuntu","link":"/tags/ubuntu/"},{"name":"우분투 한글 설정","slug":"우분투-한글-설정","link":"/tags/%EC%9A%B0%EB%B6%84%ED%88%AC-%ED%95%9C%EA%B8%80-%EC%84%A4%EC%A0%95/"},{"name":"ubuntu fcitx","slug":"ubuntu-fcitx","link":"/tags/ubuntu-fcitx/"}],"categories":[{"name":"알고리즘","slug":"알고리즘","link":"/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"모각코","slug":"모각코","link":"/categories/%EB%AA%A8%EA%B0%81%EC%BD%94/"},{"name":"Ubuntu","slug":"Ubuntu","link":"/categories/Ubuntu/"}]}